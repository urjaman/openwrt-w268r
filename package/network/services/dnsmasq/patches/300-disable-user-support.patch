diff -ur dnsmasq-2.78.old/src/dnsmasq.c dnsmasq-2.78/src/dnsmasq.c
--- dnsmasq-2.78.old/src/dnsmasq.c	2017-10-02 16:13:51.000000000 +0300
+++ dnsmasq-2.78/src/dnsmasq.c	2017-10-17 16:47:08.098569313 +0300
@@ -39,18 +39,10 @@
   struct sigaction sigact;
   struct iname *if_tmp;
   int piperead, pipefd[2], err_pipe[2];
-  struct passwd *ent_pw = NULL;
-#if defined(HAVE_SCRIPT)
-  uid_t script_uid = 0;
-  gid_t script_gid = 0;
-#endif
-  struct group *gp = NULL;
+
   long i, max_fd = sysconf(_SC_OPEN_MAX);
-  char *baduser = NULL;
   int log_err;
 #if defined(HAVE_LINUX_NETWORK)
-  cap_user_header_t hdr = NULL;
-  cap_user_data_t data = NULL;
   char *bound_device = NULL;
   int did_bind = 0;
 #endif 
@@ -380,66 +372,6 @@
   if (daemon->port != 0)
     pre_allocate_sfds();
 
-#if defined(HAVE_SCRIPT)
-  /* Note getpwnam returns static storage */
-  if ((daemon->dhcp || daemon->dhcp6) && 
-      daemon->scriptuser && 
-      (daemon->lease_change_command || daemon->luascript))
-    {
-      if ((ent_pw = getpwnam(daemon->scriptuser)))
-	{
-	  script_uid = ent_pw->pw_uid;
-	  script_gid = ent_pw->pw_gid;
-	 }
-      else
-	baduser = daemon->scriptuser;
-    }
-#endif
-  
-  if (daemon->username && !(ent_pw = getpwnam(daemon->username)))
-    baduser = daemon->username;
-  else if (daemon->groupname && !(gp = getgrnam(daemon->groupname)))
-    baduser = daemon->groupname;
-
-  if (baduser)
-    die(_("unknown user or group: %s"), baduser, EC_BADCONF);
-
-  /* implement group defaults, "dip" if available, or group associated with uid */
-  if (!daemon->group_set && !gp)
-    {
-      if (!(gp = getgrnam(CHGRP)) && ent_pw)
-	gp = getgrgid(ent_pw->pw_gid);
-      
-      /* for error message */
-      if (gp)
-	daemon->groupname = gp->gr_name; 
-    }
-
-#if defined(HAVE_LINUX_NETWORK)
-  /* determine capability API version here, while we can still
-     call safe_malloc */
-  if (ent_pw && ent_pw->pw_uid != 0)
-    {
-      int capsize = 1; /* for header version 1 */
-      hdr = safe_malloc(sizeof(*hdr));
-
-      /* find version supported by kernel */
-      memset(hdr, 0, sizeof(*hdr));
-      capget(hdr, NULL);
-      
-      if (hdr->version != LINUX_CAPABILITY_VERSION_1)
-	{
-	  /* if unknown version, use largest supported version (3) */
-	  if (hdr->version != LINUX_CAPABILITY_VERSION_2)
-	    hdr->version = LINUX_CAPABILITY_VERSION_3;
-	  capsize = 2;
-	}
-      
-      data = safe_malloc(sizeof(*data) * capsize);
-      memset(data, 0, sizeof(*data) * capsize);
-    }
-#endif
-
   /* Use a pipe to carry signals and other events back to the event loop 
      in a race-free manner and another to carry errors to daemon-invoking process */
   safe_pipe(pipefd, 1);
@@ -531,9 +463,7 @@
 	  
 	  if ((fd = open(daemon->runfile, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, S_IWUSR|S_IRUSR|S_IRGRP|S_IROTH)) == -1)
 	    {
-	      /* only complain if started as root */
-	      if (getuid() == 0)
-		err = 1;
+	    	err = 1;
 	    }
 	  else
 	    {
@@ -555,7 +485,7 @@
 	}
     }
   
-   log_err = log_start(ent_pw, err_pipe[1]);
+   log_err = log_start(NULL, err_pipe[1]);
 
    if (!option_bool(OPT_DEBUG)) 
      {       
@@ -575,100 +505,10 @@
 #ifdef HAVE_SCRIPT 
   if ((daemon->dhcp || daemon->dhcp6 || option_bool(OPT_TFTP) || option_bool(OPT_SCRIPT_ARP)) && 
       (daemon->lease_change_command || daemon->luascript))
-      daemon->helperfd = create_helper(pipewrite, err_pipe[1], script_uid, script_gid, max_fd);
+      daemon->helperfd = create_helper(pipewrite, err_pipe[1], 0, 0, max_fd);
 #endif
 
-  if (!option_bool(OPT_DEBUG) && getuid() == 0)   
-    {
-      int bad_capabilities = 0;
-      gid_t dummy;
-      
-      /* remove all supplementary groups */
-      if (gp && 
-	  (setgroups(0, &dummy) == -1 ||
-	   setgid(gp->gr_gid) == -1))
-	{
-	  send_event(err_pipe[1], EVENT_GROUP_ERR, errno, daemon->groupname);
-	  _exit(0);
-	}
-  
-      if (ent_pw && ent_pw->pw_uid != 0)
-	{     
-#if defined(HAVE_LINUX_NETWORK)	  
-	  /* On linux, we keep CAP_NETADMIN (for ARP-injection) and
-	     CAP_NET_RAW (for icmp) if we're doing dhcp. If we have yet to bind 
-	     ports because of DAD, or we're doing it dynamically,
-	     we need CAP_NET_BIND_SERVICE too. */
-	  if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
-	    data->effective = data->permitted = data->inheritable =
-	      (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | 
-	      (1 << CAP_SETUID) | (1 << CAP_NET_BIND_SERVICE);
-	  else
-	    data->effective = data->permitted = data->inheritable =
-	      (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_SETUID);
-	  
-	  /* Tell kernel to not clear capabilities when dropping root */
-	  if (capset(hdr, data) == -1 || prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) == -1)
-	    bad_capabilities = errno;
-			  
-#elif defined(HAVE_SOLARIS_NETWORK)
-	  /* http://developers.sun.com/solaris/articles/program_privileges.html */
-	  priv_set_t *priv_set;
-	  
-	  if (!(priv_set = priv_str_to_set("basic", ",", NULL)) ||
-	      priv_addset(priv_set, PRIV_NET_ICMPACCESS) == -1 ||
-	      priv_addset(priv_set, PRIV_SYS_NET_CONFIG) == -1)
-	    bad_capabilities = errno;
-
-	  if (priv_set && bad_capabilities == 0)
-	    {
-	      priv_inverse(priv_set);
-	  
-	      if (setppriv(PRIV_OFF, PRIV_LIMIT, priv_set) == -1)
-		bad_capabilities = errno;
-	    }
-
-	  if (priv_set)
-	    priv_freeset(priv_set);
-
-#endif    
-
-	  if (bad_capabilities != 0)
-	    {
-	      send_event(err_pipe[1], EVENT_CAP_ERR, bad_capabilities, NULL);
-	      _exit(0);
-	    }
-	  
-	  /* finally drop root */
-	  if (setuid(ent_pw->pw_uid) == -1)
-	    {
-	      send_event(err_pipe[1], EVENT_USER_ERR, errno, daemon->username);
-	      _exit(0);
-	    }     
-
-#ifdef HAVE_LINUX_NETWORK
-	  if (is_dad_listeners() || option_bool(OPT_CLEVERBIND))
-	   data->effective = data->permitted =
-	     (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW) | (1 << CAP_NET_BIND_SERVICE);
-	 else
-	   data->effective = data->permitted = 
-	     (1 << CAP_NET_ADMIN) | (1 << CAP_NET_RAW);
-	  data->inheritable = 0;
-	  
-	  /* lose the setuid and setgid capabilities */
-	  if (capset(hdr, data) == -1)
-	    {
-	      send_event(err_pipe[1], EVENT_CAP_ERR, errno, NULL);
-	      _exit(0);
-	    }
-#endif
-	  
-	}
-    }
-  
 #ifdef HAVE_LINUX_NETWORK
-  free(hdr);
-  free(data);
   if (option_bool(OPT_DEBUG)) 
     prctl(PR_SET_DUMPABLE, 1, 0, 0, 0);
 #endif
diff -ur dnsmasq-2.78.old/src/helper.c dnsmasq-2.78/src/helper.c
--- dnsmasq-2.78.old/src/helper.c	2017-10-02 16:13:51.000000000 +0300
+++ dnsmasq-2.78/src/helper.c	2017-10-17 16:39:59.148537810 +0300
@@ -105,27 +105,6 @@
   sigaction(SIGTERM, &sigact, NULL);
   sigaction(SIGALRM, &sigact, NULL);
 
-  if (!option_bool(OPT_DEBUG) && uid != 0)
-    {
-      gid_t dummy;
-      if (setgroups(0, &dummy) == -1 || 
-	  setgid(gid) == -1 || 
-	  setuid(uid) == -1)
-	{
-	  if (option_bool(OPT_NO_FORK))
-	    /* send error to daemon process if no-fork */
-	    send_event(event_fd, EVENT_USER_ERR, errno, daemon->scriptuser);
-	  else
-	    {
-	      /* kill daemon */
-	      send_event(event_fd, EVENT_DIE, 0, NULL);
-	      /* return error */
-	      send_event(err_fd, EVENT_USER_ERR, errno, daemon->scriptuser);
-	    }
-	  _exit(0);
-	}
-    }
-
   /* close all the sockets etc, we don't need them here. 
      Don't close err_fd, in case the lua-init fails.
      Note that we have to do this before lua init
diff -ur dnsmasq-2.78.old/src/log.c dnsmasq-2.78/src/log.c
--- dnsmasq-2.78.old/src/log.c	2017-10-02 16:13:51.000000000 +0300
+++ dnsmasq-2.78/src/log.c	2017-10-17 16:39:59.148537810 +0300
@@ -97,12 +97,6 @@
       entries_alloced = 1;
     }
 
-  /* If we're running as root and going to change uid later,
-     change the ownership here so that the file is always owned by
-     the dnsmasq user. Then logrotate can just copy the owner.
-     Failure of the chown call is OK, (for instance when started as non-root) */
-  if (log_to_file && !log_stderr && ent_pw && ent_pw->pw_uid != 0 && 
-      fchown(log_fd, ent_pw->pw_uid, -1) != 0)
     ret = errno;
 
   return ret;
diff -ur dnsmasq-2.78.old/src/tftp.c dnsmasq-2.78/src/tftp.c
--- dnsmasq-2.78.old/src/tftp.c	2017-10-02 16:13:51.000000000 +0300
+++ dnsmasq-2.78/src/tftp.c	2017-10-17 16:39:59.151871143 +0300
@@ -468,7 +468,6 @@
   char *packet = daemon->packet, *namebuff = daemon->namebuff;
   struct tftp_file *file;
   struct tftp_transfer *t;
-  uid_t uid = geteuid();
   struct stat statbuf;
   int fd = -1;
 
@@ -494,14 +493,8 @@
     goto oops;
   
   /* running as root, must be world-readable */
-  if (uid == 0)
-    {
       if (!(statbuf.st_mode & S_IROTH))
 	goto perm;
-    }
-  /* in secure mode, must be owned by user running dnsmasq */
-  else if (option_bool(OPT_TFTP_SECURE) && uid != statbuf.st_uid)
-    goto perm;
       
   /* If we're doing many transfers from the same file, only 
      open it once this saves lots of file descriptors 
